#### V8 的内存限制

在一般的后台开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScripts 使用内存时就会发现只能使用部分内存。64 位下约为 1.4G，32 位下约为 0.7G。在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如无法将一个 2GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32G。

这是因为 Node 基于 V8 构建，Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 这套内存管理机制在浏览器下绰绰有余，但在 Node 下是限制。

#### V8 的对象分配

在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。Node 提供了 V8 中内存使用量的查看方式。

```shell
> process.memoryUsage()
{ rss: 23126016,
  heapTotal: 9682944, # 已申请到的堆内存
  heapUsed: 5491088, # 已使用的堆内存
  external: 10996 }
>
```

当在代码中声明变量并赋值时，所使用对象的内存就分配在堆中，**如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存**，直到堆的大小超过 V8 的限制为止。

以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式地垃圾回收甚至要一秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间。

#### V8 的垃圾回收算法

V8 中主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。

在分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收，在 Savenge 的具体实现中，主要采用了 Cheney 算法。

Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。**处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间**。

当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中。而非存回地向占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生兑换。

#### 变量的主动释放

如果变量是全局变量，定义在 global 变量上，由于全局作用域需要知道进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过 delete 操作来删除引用关系。或者将变量重新复制，让旧的对象脱离引用关系。

#### 闭包的问题

在 JS 中，实现外部作用域访问内部作用域中变量的方法叫做闭包。

```js
var bar = function() {
  var local = "局部变量";
  return function() {
    return local;
  };
};
var baz = bar(); // local 不会被销毁，还是可以访问到
console.log(baz());
```

一般来说，在`bar()`函数执行完成后，局部变量 local 将随着作用域的销毁而销毁。但是由于这里返回值是一个匿名函数，且这个函数中具备了访问 local 的条件，虽然在后续的执行中，在外部作用域中还是无法直接访问 local，但是若要访问它，只要通过这个中间函数稍作周转即可。

闭包是 JavaScript 的高级特性，利用它可以产生很多巧妙地效果，它的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会被释放，也会导致原始的作用域不会被释放，作用域中产生的内存占用也不会得到释放。

#### 查看内存使用情况

调用 `process.memoryUsage()` 可以看到 Node 进程的内存占用情况。

`rss` 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存一共有几部分，一部分是 rss，其余部分在交换区 `swap` 或者文件系统 `filesystem` 中。

#### 堆外内存

**堆中的内存用量总是小于进程的常驻内存用量**，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。我们将那些不是通过 V8 分配的内存称为堆外内存。

#### 内存泄漏

通通常造成内存泄漏的原因有以下几个：

- 缓存
- 队列消费不及时
- 作用域未释放

#### 内存泄漏排查

一些常用的内存泄漏排查工具：

- v8-profiler
- node-heapdump
- node-mttrace
- dtrace
- node-memwatch
